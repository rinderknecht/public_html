\paragraph{Question.} The \emph{negabinary} representation of a number
is similar to the binary representation, except that the base is not
\(2\) but \(-2\). Therefore, the shape of the negabinary
representation with \(n\) bits \(b_{n-1}, b_{n-2}, \dots, b_0\) is
\[
b_{n-1}(-2)^{n-1} + b_{n-2}(-2)^{n-2} + \dots + b_1(-2)^1 + b_0
\]
Devise a \C function converting a decimal number, possibly negative,
into its negabinary form: 
{\small
\begin{verbatim}
int* from10toNeg2 (int dec);
\end{verbatim}
}
\noindent where a negabinary number is represented as a pointer to an
array of integers. For example, the implementation of the negabinary
\(1101_{-2}\) is a pointer to the leftmost cell of the array
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\emph{\textbf{4}} & \(1\) & \(1\) & \(0\) & \(1\)\\
\hline
\end{tabular}
\end{center}

\paragraph{Hints.}
\begin{enumerate}

   \item In \C, if \texttt{a => 0} and \texttt{b < 0},
     then \texttt{a/b <= 0} and \texttt{a\%b >= 0}. Also, if \texttt{a
     <= 0} and \texttt{b < 0}, then \texttt{a/b => 0} and \texttt{a\%b
     <= 0}. For instance, \(17 = (-8)(-2) + 1\) and \(-17 = 8(-2) - 1\).

  \item Compute the size \texttt{size} of the output with your
  algorithm first;

  \item allocate the result array with length \texttt{size + 1};

  \item rerun the algorithm (a loop) but, this time, fix the bits and
    save them in the resulting array.

\end{enumerate}

