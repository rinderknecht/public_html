%%-*-latex-*-

\documentclass[a4paper]{article}

\usepackage[francais]{babel}
\usepackage[OT1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}

\input{trace}

\title{Rattrapage de programmation fonctionnelle en Objective Caml}
\author{Christian Rinderknecht}
\date{19 Juin 2003}

\begin{document}

\maketitle

\smallskip

Les exercices peuvent \^etre trait\'es de fa\c{c}on
ind\'ependante. \textbf{Les documents et les calculatrices ne sont pas
autorisés.}

\smallskip


\section{Lexiques}

Un arbre peut repr\'esenter une collection de mots de sorte qu'il soit
tr\`es efficace de v\'erifier si une s\'equence donn\'ee de
caract\`eres est un mot valide ou pas. Dans ce type d'arbre, appel\'e
un {\em{trie}}, les arcs ont une lettre associ\'ee, chaque n{\oe}ud
possède une indication si la lettre de l'arc entrant est une fin de
mot et la suite des mots partageant le m\^eme d\'ebut. La figure
suivante montre le \emph{trie} des mots «~le~», «~les~», «~la~» et
«~son~», l'astérisque marquant la fin d'un mot:

\begin{center}
\includegraphics[scale=0.8]{trie.eps}
\end{center}

\noindent
On utilisera le type Caml suivant pour implanter les {\em{tries}}:

\begin{verbatim}
type trie = 
  { mot_complet : string option; suite : (char * trie) list }
\end{verbatim}

Le type prédéfini \texttt{type 'a option = None | Some of 'a} sert à
représenter une valeur éventuellement absente. Chaque n{\oe}ud d'un
\emph{trie} contient les informations suivantes:

\begin{itemize}
  \item Si le n{\oe}ud marque la fin d'un mot {\tt s} (ce qui
        correspond aux n{\oe}uds étoilés de la figure), alors le champ
        {\tt mot\_complet} contient {\tt Some s}, sinon ce champ
        contient {\tt None}.

  \item Le champ {\tt suite} contient une liste qui associe les
        caractères aux n{\oe}uds.
\end{itemize}

\medskip

\begin{itemize}

  \item[\textbf{A.1}] Écrire la valeur Caml de type \texttt{trie}
       correspondant à la figure ci-dessus.

  \item[\textbf{A.2}] Écrire une fonction \texttt{compte\_mots} qui
       compte le nombre de mots dans un \emph{trie}.

  \item[\textbf{A.3}] Écrire une fonction \texttt{select} qui prend en
       argument uen lettre et un \emph{trie}, et renvoie le
       \emph{trie} correspondant aux mots commençant par cette
       lettre. Si ce \emph{trie} n'existe pas (parce qu'aucun mot ne
       commence par cette lettre), la fonction devra lancer une
       exception {\tt Absent}, que l'on définira. On utilisera la
       fonction prédéfinie \texttt{List.assoc}~: $\forall \alpha,
       \beta.\alpha \rightarrow (\alpha \times \beta) \, \textsf{list}
       \rightarrow \beta$ pour effectuer la recherche dans la liste
       des sous-arbres \texttt{suite}.

  \item[\textbf{A.4}] Écrire une fonction \texttt{appartient} qui
       v\'erifie si une cha\^{\i}ne de caract\`eres est un mot dans un
       {\em trie} donn\'e. La fonction devra prendre un argument
       supplémentaire {\tt i}, qui représente la position dans le mot
       associée au n{\oe}ud courant.  Le i\ieme{} caractère d'une
       chaîne {\tt s} s'obtient en écrivant {\tt s.[i]}, le premier
       caractère étant numéroté $0$. La longueur de la chaîne {\tt s}
       s'écrit {\tt String.length s}. On emploiera la fonction
       \texttt{select}.

  \item[\textbf{A.5}] Application: vérificateur orthographique
       élémentaire. Écrire une fonction \texttt{vérifie} qui prend une
       liste de mots, un lexique et retourne la liste des mots du
       texte n'apparaissant pas dans le lexique.

  \item[\textbf{A.6}] On désire écrire une nouvelle fonction de
       recherche qui donne une signification spéciale au caract\`ere
       point (\texttt{.}). Ce caractère se comportera comme un
       \emph{joker} pouvant remplacer n'importe quelle lettre. Écrire
       une fonction qui prend en entr\'ee un lexique et un mot pouvant
       contenir le \emph{joker}, et retourne la liste de tous les mots
       correspondant.

  \item[\textbf{A.7}] Écrire une fonction qui ajoute un mot à un
       \emph{trie} (c'est-à-dire qu'elle renvoie un nouveau
       \emph{trie} contenant en plus ce mot).

\end{itemize}


\section{Tri par fusion (\emph{Merge sort})}

On se propose de programmer un algorithme de tri sur les listes, dit
\emph{tri par fusion}. L'idée est de commencer par programmer
l'opération de fusion, qui prend deux listes déjà triées et en fait
une seule liste triée.

Ensuite, on transforme notre liste à trier, contenant $n$ éléments, en
$n$ listes à un élément. Puis on fusionne ces listes deux par deux, ce
qui nous donne $n/2$ listes triées à deux éléments, plus
éventuellement une liste à un élément (si $n$ est impair). On les
fusionne à nouveau deux par deux, etc. jusqu'à ce qu'il ne reste plus
qu'une seule liste, qui est alors triée.

Il est intéressant de noter que le type des éléments manipulés n'a pas
d'importance, parce que la fonction de comparaison \texttt{ordre} sera
polymorphe: elle aura le type
$\forall\alpha.\alpha\rightarrow\alpha\rightarrow\textsf{bool}$.  Cela
permet d'utiliser la même fonction \texttt{mergesort} pour trier des
listes d'entiers, de flottants, de listes, etc. sans limitation. De
plus, cela permettra de trier par ordre croissant ou décroissant,
selon l'implantation de la fonction \texttt{ordre}.

\begin{itemize}

  \item[\textbf{B.1}] \'{E}crire une fonction \texttt{singletons} qui
      prend en argument une liste \texttt{[x1; ...; xn]} et renvoie la
      liste des listes à un élément \texttt{[[x1]; ...; [xn]]}. On
      pourra utiliser {\tt List.map}: $\forall \alpha,\beta.(\alpha
      \rightarrow \beta) \rightarrow \alpha \, \textsf{list}
      \rightarrow \beta \, \textsf{list}$ qui calcule la liste des
      images par une fonction donnée d'une liste d'antécédents donnés.

  \item[\textbf{B.2}] \'{E}crire une fonction {\tt merge} qui prend en
      argument la fonction de comparaison \texttt{ordre}, deux listes
      triées et les fusionne en une seule liste triée.

  \item[\textbf{B.3}] \'{E}crire une fonction {\tt merge2à2} qui prend
      en argument la fonction de comparaison \texttt{ordre}, une liste
      de listes \texttt{[l1; l2; l3; l4; ...]}  et renvoie une liste
      où les listes voisines ont été fusionnées, i.e.  \texttt{[merge
      ordre l1 l2; merge ordre l3 l4; ...]}. On prendra garde à
      traiter correctement le cas où la liste d'entrée est de longueur
      impaire.

  \item[\textbf{B.4}] En combinant les fonctions précédentes, écrire
      une fonction {\tt mergesort} qui prend en argument la fonction
      de comparaison \texttt{ordre}, une liste et la trie. Pour cela,
      on crée la liste des listes à un élément, puis on lui applique
      {\tt merge2à2} itérativement jusqu'à obtenir une liste de la
      forme \texttt{[l]}. On renvoie alors \texttt{l}.

  \item[\textbf{B.5}] Exprimer le nombre maximal de comparaisons
      nécessité par chacune des fonctions ci-dessus, en fonction de la
      taille de son argument. En déduire que le tri d'une liste de
      taille $n$ demande un temps $O(n \cdot \log_2 n)$.
  
\end{itemize}


\section{Tri rapide (\emph{Quicksort})}

\begin{itemize}

  \item[\textbf{C.1}] \'{E}crire une fonction {\tt partage} qui prend
     en argument un prédicat {\tt p} et une liste {\tt l} et renvoie
     un couple formé de la liste des éléments de {\tt l} qui vérifient
     {\tt p} et de la liste de ceux qui ne le vérifient pas.

  \item[\textbf{C.2}] On choisit un élément {\tt p} de la liste,
     appelé \emph{pivot}. On sépare ensuite la liste en trois parties:
     le pivot {\tt p}, la liste {\tt l1} des éléments plus petits que
     {\tt p}, et la liste {\tt l2} des éléments plus grands que, ou
     égaux à {\tt p}. (On peut utiliser la fonction {\tt partage}
     écrite précédemment.)  La liste triée est alors égale à la
     concaténation de \texttt{l1} triée, {\tt p} et \texttt{l2} triée.

\end{itemize}

\end{document}
